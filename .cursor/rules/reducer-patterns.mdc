---
description: TCA reducer patterns - apply when implementing reducers, effects, or handling actions in Composable Architecture
globs: ["Sources/**/*.swift"]
---

# Reducer Patterns

**Key Points:**
- Use `@Reducer` macro
- `@ObservableState` for observation
- Group actions by source: `View`, `Delegate`, etc
- `ViewAction` protocol for view-initiated actions
- State should conform to `Equatable`
- Use IdentifiedArray if element is Identifiable
- Declare dependencies with `@Dependency` as `private var` properties between Action enum and body

## Reducer Structure

```swift
@Reducer
struct FeatureReducer: Reducer {
    @ObservableState
    struct State: Equatable {
        // State properties
    }

    enum Action: ViewAction {
        enum View {
            case buttonTapped
        }
        case view(View)
    }

    @Dependency(\.continuousClock) private var clock
    @Dependency(\.defaultDatabase) private var database

    var body: some ReducerOf<Self> {
        Reduce { state, action in
            // Reducer logic using dependencies
        }
    }
}
```

**Key Points:**
- Dependencies are accessible throughout the reducer body and effects
- Mark dependencies as `private` for encapsulation
- Dependencies placed between Action and body follow TCA conventions

## Reducer Composition Patterns

**Key Points:**
- Compose reducers from small, focused pieces
- Use `Scope` for required child state
- Use `.forEach` for collections
- Use `.ifLet` for optional presentations
- Order matters: child reducers run before parent

## Effect Patterns

### Simple Run Effect

```swift
case .buttonTapped:
    return .run { send in
        let result = await someAsyncOperation()
        await send(.operationCompleted(result))
    }
```

### Cancellable Effects

```swift
@Dependency(\.continuousClock) private var clock
private enum CancelID { case timer }

case .startTimer:
    return .run { send in
        for await _ in clock.timer(interval: .seconds(1)) {
            await send(.timerTicked)
        }
    }
    .cancellable(id: CancelID.timer, cancelInFlight: true)

case .stopTimer:
    return .cancel(id: CancelID.timer)
```

### Debounced Effects

```swift
case .searchQueryChanged:
    return .run { send in
        try await clock.sleep(for: .milliseconds(300))
        await send(.performSearch)
    }
    .cancellable(id: CancelID.search, cancelInFlight: true)
```

### Effects with Error Handling

For operations that should never fail due to programmer error (not user error):

```swift
import IssueReporting

case .deleteButtonTapped:
    let id = state.itemID
    return .run { _ in
        withErrorReporting {
            try await database.write { db in
                try Item.find(id).delete().execute(db)
            }
        }
    }
```

**Key Points:**
- Use `.run` for async effects
- Use `.cancellable` with IDs for cancellation
- `cancelInFlight: true` for debouncing
- Dependencies are accessed directly (not with `self.`)
- **Wrap programmer errors with `withErrorReporting`**: Database operations with valid data, schema operations, etc.
- **Don't wrap user errors**: Network failures, invalid user input, permission denials - handle these explicitly

## Delegate Pattern

Parent-child communication using delegates:

```swift
// Child Reducer
enum Action {
    case delegate(Delegate)

    enum Delegate {
        case didFinish(Result<State, Error>)
        case playbackStarted
    }
}

// Parent Reducer
case .recordingMemo(.presented(.someFeature(.delegate(delegateAction)))):
switch delegateAction {
    case .didFinish...:
    return .none

    case .playbackStarted:
    return .none
}
```

**Key Points:**
- Child sends delegate actions to communicate with parent
- Parent observes nested delegate actions
- Useful for presentation dismissal and data flow
