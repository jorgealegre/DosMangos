---
alwaysApply: true
---

## Navigation Patterns

### NavigationStack with TCA

```swift
@Reducer
enum Destination {
    case transactionForm(TransactionForm)
}

@ObservableState
struct State: Equatable {
    @Presents var destination: Destination.State?
}

// View
ContentView(store: store)
.sheet(
    item: $store.scope(state: \.destination?.transactionForm, action: \.destination.transactionForm)
) { store in
    TransactionFormView(store: store)
}
```

**Key Points:**
- Use `@Reducer enum` for destination types
- `@Presents` for optional presentation
- Scope store to destination

### Dismissal Patterns

```swift
@Dependency(\.dismiss) var dismiss

case .saveButtonTapped:
    return .run { _ in
        await dismiss()
    }
```

**Key Points:**
- Use dismiss dependency in TCA reducers
- Call in async effects
- Automatically dismisses the current presentation

### Alert Navigation

```swift
// Define alert actions
enum AlertAction {
    case confirmDeletion
    case continueWithoutRecording
    case openSettings
}

// Create alert states
extension AlertState where Action == FeatureReducer.AlertAction {
    static let deleteItem = Self {
        TextState("Delete?")
    } actions: {
        ButtonState(role: .destructive, action: .confirmDeletion) {
            TextState("Yes")
        }
        ButtonState(role: .cancel) {
            TextState("Nevermind")
        }
    } message: {
        TextState("Are you sure you want to delete this item?")
    }
}

// Show alert in reducer
case .deleteButtonTapped:
    state.alert = .deleteItem
    return .none

// Handle in view
.alert($store.scope(state: \.alert, action: \.alert))
```

**Key Points:**
- Type-safe alert actions
- Reusable alert configurations
- Use `AlertState` for structured alerts
- Handle alert responses in reducer
